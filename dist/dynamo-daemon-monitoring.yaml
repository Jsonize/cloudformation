AWSTemplateFormatVersion: 2010-09-09

# https://s3.amazonaws.com/cloudformation.jsonize.com/dynamo-daemon-monitoring.yaml

Description: Monitor daemons via DynamoDB and CloudWatch Alarms


Parameters:

  DynamoDataTable:
    Type: String
    Description: The name of the monitoring data table
    Default: daemon-monitoring-records

  DynamoConfigTable:
    Type: String
    Description: The name of the monitoring config table
    Default: daemon-monitoring-config

  AlarmSNSTopic:
    Type: String
    Description: The SNS topic ARN that should be used for alarms

  ScheduleExpression:
    Type: String
    Description: Schedule expression, e.g. 'rate(6 hours)'
    Default: rate(15 minutes)


Resources:

  LambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: "/"
      Policies:
        - PolicyName: logs
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:*
                Resource:
                  - arn:aws:logs:*:*:*
        - PolicyName: dynamo
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:CreateTable
                  - dynamodb:GetItem
                  - dynamodb:Scan
                  - dynamodb:Query
                Resource:
                  - !Join [ "", [ "arn:aws:dynamodb:*:*:table/", !Ref DynamoDataTable ] ]
                  - !Join [ "", [ "arn:aws:dynamodb:*:*:table/", !Ref DynamoConfigTable ] ]
        - PolicyName: sns
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - sns:Publish
                Resource:
                  - !Ref AlarmSNSTopic

  LambdaFunction:
    Type: AWS::Lambda::Function
    DependsOn:
      - LambdaRole
    Properties:
      Code:
        ZipFile: |
          _B=None
          _A='date'
          import boto3,os
          from botocore.exceptions import ClientError
          from boto3.dynamodb.conditions import Key
          import re,datetime,json
          def parseDuration(s):B={'second':1,'minute':60,'hour':3600,'day':86400,'week':604800,'month':2592000};A=re.compile('(\\d+)\\s+([a-z]+[^s])s?').match(s);return int(A.group(1))*B[A.group(2)]
          def parseLastInvocation(s):
          	A=re.compile('rate\\((.*)\\)').match(s)
          	if A!=_B:return datetime.datetime.now()-datetime.timedelta(seconds=parseDuration(A.group(1)))
          	B=re.compile('cron\\((.*)\\)').match(s)
          	if B!=_B:return
          def log(s):print(s)
          def getTable(db,name,hashKey,rangeKey=_B):
          	F='AttributeType';E='KeyType';B=hashKey;A='AttributeName'
          	try:
          		C=[{A:B,E:'HASH'}];D=[{A:B,F:'S'}]
          		if rangeKey!=_B:C.append({A:_A,E:'RANGE'});D.append({A:_A,F:'S'})
          		return db.create_table(TableName=name,KeySchema=C,AttributeDefinitions=D,BillingMode='PAY_PER_REQUEST')
          	except ClientError:return db.Table(name)
          def handler(event,context):
          	g='timeout';f='contexts';e='alternativeDaemonName';d='enabled';c='LastEvaluatedKey';W='ALARM ';V='success';U='invocation';T='context';S='state';R='Items';O=': ';N='default';M='daemonName';K=' ';J='pending';H=context;X=boto3.resource('dynamodb');h=boto3.client('sns');i=getTable(X,os.environ['DYNAMO_DATA_TABLE'],M,_A);Y=getTable(X,os.environ['DYNAMO_CONFIG_TABLE'],M);j=os.environ['SNS_TOPIC'];I=Y.scan();Z=I[R]
          	while c in I:I=Y.scan(ExclusiveStartKey=I[c]);Z.extend(I[R])
          	for A in Z:
          		if d in A and not A[d]:continue
          		log(A);F=A[M];k=A['minInvocations'];l=parseDuration(A['thresholdStart']);m=parseDuration(A['timeoutEnd']);a=parseLastInvocation(A['schedule']);P=[F]
          		if e in A:P.append(A[e])
          		for(n,o)in enumerate(P):
          			p=i.query(KeyConditionExpression=Key(M).eq(o)&Key(_A).gte(a.isoformat()));C={}
          			if f in A:
          				for E in A[f]:C[E]={}
          			else:C[N]={}
          			L=p[R]
          			for B in L:B[_A]=B[_A].split('~',1)[0]
          			L.sort(key=lambda x:x[S]);L.sort(key=lambda x:x[_A])
          			for B in L:
          				if not N in C:
          					if not T in B:continue
          					if not B[T]in C:continue
          					H=C[B[T]]
          				else:H=C[N]
          				if not B[U]in H:H[B[U]]={V:0,g:0,J:_B}
          				G=H[B[U]];Q=datetime.datetime.strptime(B[_A],'%Y-%m-%dT%H:%M:%S')
          				if B[S]=='start':
          					if Q<=a+datetime.timedelta(seconds=l):G[J]=Q
          				if B[S]=='stop'and G[J]!=_B:
          					if Q<=G[J]+datetime.timedelta(seconds=m):G[V]+=1
          					else:G[g]+=1
          					G[J]=_B
          			for(q,r)in C.items():
          				D=0
          				for(t,s)in r.items():D+=s[V]
          				C[q]=D
          			if not C:C[N]=0
          			b=False
          			for(E,D)in C.items():
          				log(F+K+E+O+str(D))
          				if D<k:
          					if n==len(P)-1:log(W+F+K+E+O+str(D));h.publish(TopicArn=j,Message=json.dumps({'AlarmName':F+K+E,'OldStateValue':'UNKNOWN','NewStateValue':'ALARM','NewStateReason':W+F+K+E+O+str(D)}),Subject=W+F+K+E+O+str(D))
          				else:b=True
          			if b:break
      Environment:
        Variables:
          DYNAMO_DATA_TABLE: !Ref DynamoDataTable
          DYNAMO_CONFIG_TABLE: !Ref DynamoConfigTable
          SNS_TOPIC: !Ref AlarmSNSTopic
      Handler: index.handler
      Role: !GetAtt LambdaRole.Arn
      Runtime: python3.12
      Timeout: 60

  ScheduledLambdaEventRule:
    Type: AWS::Events::Rule
    Properties:
      ScheduleExpression: !Ref ScheduleExpression
      State: ENABLED
      Targets:
        - Id: IdScheduledLambda
          Arn: !GetAtt LambdaFunction.Arn

  ScheduledLambdaPermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - ScheduledLambdaEventRule
    Properties:
      FunctionName: !GetAtt LambdaFunction.Arn
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt ScheduledLambdaEventRule.Arn
